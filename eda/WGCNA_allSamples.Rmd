---
title: "WGCNA of glyco-enzyme data"
author: "Cynthia Tang"
date: "1/28/2021"
output: 
    html_document:
        toc: true
        toc_float: true
        code_folding: show
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# library(clusterProfiler)
library(tibble)
library(factoextra)
library(plotly)
library(shiny)
library(HTSet)
library(dplyr)
library(DT)
library(org.Hs.eg.db)
library(ggplot2)
library(limma)
library(anRichment)
library(WGCNA)
```

# 1 Data input, cleaning and pre-processing

## 1.a Load ROSMAP transcriptome data
```{r}
FCData <- readRDS("../data/rosmap.rds")$dorsolateral
glyco <- readRDS("../data/glyco_reactome.rds") 
datExpr0 <- readRDS("../data/rosmap_normalized.rds")
DE_ad <- readRDS("../data/DE_rosmap.rds")$dorsolateral$AD
# Select glyco-genes
datExpr0 <- datExpr0[rownames(datExpr0) %in% glyco$Ensembl,] 
FCData_glyco <- HTSet(edata = datExpr0, pdata = FCData$pdata, fdata = FCData$fdata[rownames(datExpr0),])
# Discard other dementia group
FCData_glyco <- subset_samples(FCData_glyco, FCData_glyco$pdata$diagnosis != "Other")
FCData_glyco$pdata$diagnosis <- droplevels(FCData_glyco$pdata$diagnosis, "Other")
# Prepare datExpr
datExpr0 <- FCData_glyco$edata %>%
    as.data.frame() %>%
    t()
datExpr0[datExpr0 == 0] <- NA
```

## 1.b  Checking data for excessive missing values and identification of outlier microarray samples

First, we cluster the samples to see if there are any obvious outliers.

```{r}
sampleTree <- hclust(dist(datExpr0), method = "average")
# sizeGrWindow(12,9)
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", 
     xlab="", cex = 1)
```

There are some outliers.

```{r}
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", 
     xlab="", labels=FALSE)
abline(h = 30, col = "red")
# Determine cluster under the line
clust <- cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
datExpr0 <- datExpr0[clust==1, ]
# nGenes <- ncol(datExpr)
# nSamples <- nrow(datExpr)
```

We first check for genes and samples with too many missing values:

```{r}
gsg <- goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
```
```{r}
datExpr <- datExpr0
```

Now data in datExpr is ready for network analysis. We are selecting trait data, APOE genotype, Braak score, CERAD score, cognitive diagnosis and Clinical diagnosis of cognitive status.

```{r}
colnames(FCData_glyco$pdata)
datTrait <- FCData_glyco$pdata[,c("apoe_genotype", "braaksc", "ceradsc", "cogdx", "dcfdx_lv", "diagnosis")]
datTrait <- datTrait[rownames(datExpr),] %>%
    mutate_all(as.factor) %>%
    mutate(diagnosis = factor(diagnosis, levels = c('NCI', 'MCI', 'AD'), labels = 1:3))

collectGarbage()
```

# 2 Automatic construction of the gene network and identification of modules

## 2.a. Choosing the soft-thresholding power: analysis of network topology

```{r}
# Choose a set of soft-thresholding powers
powers <- c(c(1:10), seq(12, 30, 2))
# Call the network topology analysis function
sft <- pickSoftThreshold(data = datExpr, powerVector = powers, verbose = 5)
# Plot the results:
par(mfrow = c(1, 2))
cex1 <- 0.9
# Scale-free topology fit index as a function of the soft-thresholding power
plot(x = sft$fitIndices[, 1], y = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",
     ylab="Scale Free Topology Model Fit,signed R^2",
     type="n",
     main = paste("Scale independence"))
text(x = sft$fitIndices[, 1], y = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels = powers, cex=cex1, col = "red")
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(x = sft$fitIndices[,1], sft$fitIndices[,5],
     xlab = "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

We choose the power 4, which is the lowest power for which the scale-free topology reaching a high value (in this case, roughly 0.9).

### 2.a.2 One-step network construction and module detection

Constructing the gene network and identifying modules is now a simple function call:

```{r}
power <- 4
net <- blockwiseModules(
    datExpr = datExpr,
    power = power,
    TOMType = "unsigned",
    minModuleSize = 14,  
    reassignThreshold = 0,
    mergeCutHeight = 0.25,  # the threshold for merging modules
    numericLabels = TRUE,   # return numeric, rather than color, labels for module
    pamRespectsDendro = FALSE,
    saveTOMs = TRUE,        # save the Topological Overlap Matrix
    saveTOMFileBase = "glycoTOM",
    verbose = 3
)
# we will use colors, MEs, dendrograms[[1]], blockGenes[[1]]
```

```{r}
table(net$colors)
```
There are 5 modules, labeled 1 through 5 in order of descending size, with sizes ranging from 105 to 20 genes. *The label 0 is reserved for genes outside of all modules*.

The hierarchical clustering dendrogram (tree) used for the module identification:

```{r}
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors <- labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
renderPlot({
    plotDendroAndColors(
        dendro = net$dendrograms[[1]],
        colors = mergedColors[net$blockGenes[[1]]],
        groupLabels = "Module colors",
        dendroLabels = FALSE, hang = 0.03,
        addGuide = TRUE, guideHang = 0.05
    )
})
moduleLabels <- net$colors
moduleColors <- labels2colors(net$colors)
MEs <- net$MEs
geneTree <- net$dendrograms[[1]]
colnames(MEs) <- colnames(MEs) %>% substring(3) %>% as.numeric %>% labels2colors() %>% paste0("ME",.)
```

# 3. Relating modules to external information and identifying important genes

## 3.a Quantifying module–trait associations

In this analysis we would like to identify modules that are significantly associated with the measured clinical traits. Since we already have a summary profile (*eigengene*) for each module, we simply correlate eigengenes with external traits and look for the most significant associations:

QUESTION: How to calculate the effect size (strength of association) between a continuous variable and a categorical variable?
Answer: using biweight midcorrelations between each module eigenvalue and each of clinical or neuropathological traits.

```{r}
# Recalculate MEs with color labels
# MEs0 <- moduleEigengenes(expr = datExpr, colors = moduleColors)$eigengenes
# MEs <- orderMEs(MEs0)
# Modify the colnames of MEs:
moduleTraitCor <- bicor(MEs, datTrait, robustX = FALSE, robustY = FALSE, use = "p") # pairwise correlation
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples = nrow(datExpr))
```

Since we have a moderately large number of modules and traits, a suitable graphical representation will help in reading the table. We color code each association by the correlation value:

```{r eval=FALSE, include=FALSE}
sizeGrWindow(10, 6)
# will display correlations and their p-values
textMatrix <- paste0(
    signif(moduleTraitCor, 2), "\n(",
    signif(moduleTraitPvalue, 1), ")"
)
dim(textMatrix) <- dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3))
# Display the correlation values within a heatmap plot
renderPlot({
    labeledHeatmap(
        Matrix = moduleTraitCor,
        xLabels = colnames(datTrait),
        yLabels = colnames(MEs),
        ySymbols = colnames(MEs),
        colorLabels = FALSE,
        colors = greenWhiteRed(50),
        textMatrix = textMatrix,
        setStdMargins = FALSE,
        cex.text = 0.5,
        zlim = c(-1, 1),
        main = "Module-trait relationships"
    )
})
```

## 3.b Gene relationship to trait and important modules: Gene Significance and Module Membership

We quantify associations of individual genes with our trait of interest (weight) by defining **Gene Significance GS** as (the absolute value of) **the correlation between the gene and the trait**. For each module, we also define a quantitative measure of **module membership MM** as **the correlation of the module eigengene and the gene expression profile**. This allows us to quantify the similarity of all genes on the array to every module.

geneModuleMembership (MM): genes --> module  
geneTraitSignificance (GS): genes --> trait

```{r}
# Define variable diagnosis
dx <- data.frame(
    diagnosis = datTrait$diagnosis,
    Braak = datTrait$braaksc,
    CERAD = datTrait$ceradsc,
    APOE = datTrait$apoe_genotype
)
# names (colors) of the modules
modNames <- substring(names(MEs), first = 3)

geneModuleMembership <- cor(datExpr, MEs, use = "p")
MMPvalue <- as.data.frame(corPvalueStudent(geneModuleMembership, nSamples = nrow(datExpr)))

# change the colnames of geneModuleMembership and MMPvalue
geneModuleMembership <- as.data.frame(geneModuleMembership)
colnames(geneModuleMembership) <- paste0("MM", substring(names(MEs), first = 3))
colnames(MMPvalue) <- paste0("p.MM", substring(names(MEs), first = 3))

geneTraitSignificance <- bicor(datExpr, dx, robustX = FALSE, robustY = FALSE, use = "p")
GSPvalue <- as.data.frame(corPvalueStudent(geneTraitSignificance, nSamples = nrow(datExpr)))
geneTraitSignificance <- as.data.frame(geneTraitSignificance)
colnames(geneTraitSignificance) <- paste0("GS", names(dx))
colnames(GSPvalue) <- paste0("p.GS", names(dx))

# identical(rownames(geneTraitSignificance), rownames(GSPvalue))
# sigGenes <- cbind(geneTraitSignificance, GSPvalue) %>%
#     tibble::rownames_to_column("Ensembl") %>%
#     left_join(glyco[, 3:5], by = "Ensembl")
# datatable(sigGenes, rownames = FALSE) %>%
#     formatSignif(2:9)
```

## 3.c Intramodular analysis: identifying genes with high GS and MM

Using the GS and MM measures, we can identify genes that have a high significance for diagnosis as well as high module membership in interesting modules. As an example, we look at the blue module that has the highest association with diagnosis. We plot a scatterplot of Gene Significance vs. Module Membership in the blue module:

```{r echo=FALSE}
tags$div(
    class = "row",
    tags$div(
        class="col-sm-6",
        selectInput("module", label = "Module", choices = modNames[-length(modNames)])
    )
)
```


```{r}
keyGenes <- vector("list", length = length(modNames)-1)
names(keyGenes) <- modNames[1:length(modNames)-1]
names(moduleColors) <- names(net$colors)
for (module in names(keyGenes)) {
    column <- match(module, modNames)
    moduleGenes <- moduleColors == module
    keyGenes[[module]] <- data.frame(
        Ensembl = names(moduleColors)[moduleGenes],
        Symbol = glyco$Name[match(names(moduleColors)[moduleGenes], glyco$Ensembl)],
        MM = abs(geneModuleMembership[moduleGenes, column]),
        GS = abs(geneTraitSignificance[moduleGenes, "GSdiagnosis"])
    ) %>%
        left_join(glyco[,c("Ensembl", "Class")], by = "Ensembl")
}

renderDT({
    datatable(keyGenes[[input$module]], rownames = FALSE) %>%
        formatSignif(3:4)
})
renderPlotly({
    ggplot(keyGenes[[input$module]], aes(MM, GS)) +
        geom_point(aes(Symbol = Symbol), shape = 21, fill = input$module, color = "black", size = 2) +
        labs(
            x = paste("Module Membership in", input$module, "module"),
            y = "Gene significance for diagnosis",
            main = paste("Module membership vs. gene significance\n")
        ) + 
        theme_bw()
})

# verboseScatterplot(
#     x = abs(geneModuleMembership[moduleGenes, column]),
#     y = abs(geneTraitSignificance[moduleGenes, 1]),
#     xlab = paste("Module Membership in", module, "module"),
#     ylab = "Gene significance for body weight",
#     main = paste("Module membership vs. gene significance\n"),
#     cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, 
#     col = module
# )
```
## 3.d glycosylation type enrichment analysis

Greate a gene set of glycosylation types and calculate the enrichment within each module.

```{r}
oEntrez <- glyco %>%
    filter(Class == "O-glycosylation")
oEntrez <- oEntrez$entrez
nEntrez <- glyco %>%
    filter(Class == "N-glycosylation")
nEntrez <- nEntrez$entrez
oGeneSet <- newGeneSet(
    geneEntrez = oEntrez,
    geneEvidence = "IC",
    geneSource = "Reactome",
    ID = "Glycosylation01",
    name = "O-glycosylation",
    description = "Genes in O-glycosylation pathway",
    source = "Reactome",
    organism = "human",
    internalClassification = c("Glyco", "Glycosylation"),
    groups = "Glyco"
)
nGeneSet <- newGeneSet(
    geneEntrez = nEntrez,
    geneEvidence = "IC",
    geneSource = "Reactome",
    ID = "Glycosylation02",
    name = "N-glycosylation",
    description = "Genes in N-glycosylation pathway",
    source = "Reactome",
    organism = "human",
    internalClassification = c("Glyco", "Glycosylation"),
    groups = "Glyco"
)
Glycogroup <- newGroup(name = "Glyco", description = "Glycosylation group of gene sets",
                   source = "Reactome")
Glycocollection <- newCollection(dataSets = list(oGeneSet, nGeneSet), groups = list(Glycogroup))
rows <- match(names(moduleColors), glyco$Ensembl)
entrez <- glyco$entrez[rows]
glycoEnrichment <- enrichmentAnalysis(
    classLabels = moduleColors,
    identifiers = entrez,
    refCollection = Glycocollection,
    useBackground = "given",
    threshold = 5e-2,
    nBestDataSets = 3,
    thresholdType = "FDR"
)
enrichtbl <- glycoEnrichment$enrichmentTable
datatable(enrichtbl[, c(1, 4, 6, 7, 8)], rownames = FALSE) %>%
    formatSignif(3:5)
```

# 4 Visulization

## 4.a Glyco-network intermodular relationships of the identified 5 co-regulation modules
```{r}
# Plot the relationships among the eigengenes and the trait
renderPlot({
    plotEigengeneNetworks(
        multiME = MEs,
        setLabels = "",
        marDendro = c(0, 4, 1, 2),
        marHeatmap = c(3, 4, 1, 2),
        cex.lab = 0.8,
        xLabelsAngle = 90,
        colorLabels = TRUE
    )
})
```

## 4.b Module-trait correlation

Module-trait correlation between each of the 7 modules and each AD-relevant phenotypic or genotypic trait is shown by signed −log10 P to indicate the significance and direction of the correlation. Modules with significant correlation (P < 0.05) are labeled.

```{r}
METtbl <- (-log10(moduleTraitPvalue) * sign(moduleTraitCor)) %>%
    as.data.frame() %>%
    dplyr::select(-c("cogdx", "dcfdx_lv")) %>%
    tibble::rownames_to_column("module") %>%
    tidyr::pivot_longer(2:5, names_to = "trait", values_to = "signedLogP") %>%
    filter(module != "MEgrey") %>%
    mutate(module = factor(module, levels = rownames(moduleTraitCor)[-length(rownames(moduleTraitCor))]))
renderPlotly({
    ggplot(METtbl, aes(trait, signedLogP)) +
        geom_col(aes(fill = module), position = "dodge2", width = 0.7, color = "black") +
        geom_hline(yintercept = c(-log10(0.05), log10(0.05)), linetype = 2) +
        scale_fill_manual(values=substring(levels(METtbl$module), 3)) +
        theme_bw()
})
```

## 4.c Box plots of module eigen (ME) values in AD and control cases

Box plots of module eigenglycopeptide (MEg) values in AD and control cases for each AD-related module, with differences in module eigenglycopeptide between AD and control shown by Kruskal-Wallis test P values.


```{r}
pdata <- FCData_glyco$pdata[rownames(MEs),]
edata <- as.matrix(t(MEs))
model <- model.matrix(~diagnosis, data = pdata)

output$box <- renderDT({
    lmFit(edata, model) %>%
        eBayes() %>%
        topTable(coef = 3, number = Inf, sort.by = "none") %>%
        datatable(selection = list(mode = "single", selected = 1)) %>%
        formatSignif(columns = 1:6)
})
dataTableOutput("box")
MEDxtbl <- vector("list", length = length(modNames)-1)
names(MEDxtbl) <- modNames[-length(modNames)]
for (module in names(MEDxtbl)) {
    column <- match(module, modNames)
    MEDxtbl[[module]] <- data.frame(
        MEg = MEs[,column],
        diagnosis = pdata$diagnosis
    )
}
renderPlotly({
    ggplot(MEDxtbl[[input$box_rows_selected]], aes(diagnosis, MEg)) +
        geom_boxplot(fill = modNames[input$box_rows_selected], alpha = 0.7) +
        geom_point(alpha = 0.3) +
        theme_bw()
})
```

# 5. Exploratory analysis

```{r echo=FALSE}
tags$div(
    class = "row",
    tags$div(
        class="col-sm-6",
        selectInput("module5", label = "Module", choices = modNames[-length(modNames)])
    )
)
```

```{r}
blue <- reactive({
    datExpr[,moduleColors==input$module5]
})
pca_blue <- reactive({
    prcomp(blue(), center = T, scale. = T)
})
renderPlot({
    plot(x = 1:100, y = MEs[,paste0("ME", input$module5)][1:100], "l")
    # pca_blue$x[1:100, 1]/MEs$MEblue[1:100]
})
renderPlot({
    plot(x = 1:100, y = pca_blue()$x[1:100,1], "l")
})

# variable contribution:
renderDT({
    res.var <- get_pca_var(pca_blue())
    # plot(1:116, res.var$contrib[,1], "l")
    contribution <- data.frame(
        Ensembl = rownames(res.var$contrib),
        Contribution = res.var$contrib[,1],
        direction = sign(res.var$cor[,1])
    ) %>%
        left_join(glyco[,3:5], by = "Ensembl") %>%
        dplyr::arrange(desc(Contribution)) 
    datatable(contribution) %>%
        formatSignif(columns = 2, digits = 3)
})
# ENSG to hgnc_symbol:
blue2 <- reactive({
    blue2 <- blue()
    colname <- glyco[,c(3, 5)] %>%
        distinct() %>%
        dplyr::filter(Ensembl %in% colnames(blue())) %>%
        column_to_rownames("Ensembl")
    colnames(blue2) <- colname[colnames(blue()),1]
    blue2
}) 
renderPlot({
    res.var <- get_pca_var(pca_blue())
    contribution <- data.frame(
        Ensembl = rownames(res.var$contrib)[res.var$contrib[,1]>1],
        Contribution = res.var$contrib[res.var$contrib[,1]>1,1]
    ) %>%
        left_join(glyco[,3:5], by = "Ensembl") %>%
        dplyr::arrange(desc(Contribution)) 
    pca_blue2 <- prcomp(blue2(), center = T, scale. = T)
    par(mfrow = c(1, 2))
    fviz_pca_var(pca_blue2)
    fviz_pca_var(pca_blue2, select.var = list(name = contribution$Name[1:20]), repel = T)
    
})
```

## 5.1 GO enrichment

```{r echo=FALSE}
tags$div(
    class = "row",
    tags$div(
        class="col-sm-6",
        selectInput("bg", label = "Background", choices = c("given", "reference"))
    )
)
```

```{r}
GOcollection = buildGOcollection(organism = "human")
ensembl2entrez <- glyco$entrez
names(ensembl2entrez) <- glyco$Ensembl
entrez <- ensembl2entrez[names(moduleColors)]
GOres <- list(given = NULL, reference = NULL)
for (bg in names(GOres)) {
    GOenrichment = enrichmentAnalysis(
        classLabels = moduleColors, identifiers = entrez,
        refCollection = GOcollection,
        useBackground = bg,
        threshold = 0.05,
        thresholdType = "FDR",
        getOverlapEntrez = TRUE,
        getOverlapSymbols = TRUE,
        ignoreLabels = "grey")
    GOres[[bg]] <- GOenrichment$enrichmentTable
}
renderDT({
    print(head(GOres[[input$bg]]))
    datatable(GOres[[input$bg]])
})
# genes_modx <- entrez[moduleColors == "blue"]
# blue_MF <- enrichGO(gene = genes_modx, OrgDb = org.Hs.eg.db, ont = "MF")
```

# 6. Cytoscape Network

```{r eval=FALSE}
# Recalculate topological overlap if needed
load("glycoTOM-block.1.RData")
# Read in the annotation file
annot <- FCData_glyco$fdata
# Select module probes
# probes <- vector("list", length = length(modNames)-1)
# names(probes) <- modNames[-length(modNames)]
# symbols <- probes
for (module in modNames[-length(modNames)]) {
    # select top 20 genes with highest MM
    ## top20 MM values
    ### identical(names(moduleColors), rownames(geneModuleMembership))
    rows <- moduleColors == module
    cols <- grep(module,colnames(MMPvalue))
    top40 <- abs(geneModuleMembership[rows,cols]) %>%
        sort(decreasing = TRUE) %>%
        head(40)
    ind <- match(top40, abs(geneModuleMembership[,grep(module,colnames(MMPvalue))]))
    probes <- rownames(geneModuleMembership)[ind]
    symbols <- annot[probes,]$hgnc_symbol # corresponding symbols
    # Select the corresponding Topological Overlap
    modTOM <- as.matrix(TOM)
    dimnames(modTOM) <- list(colnames(datExpr), colnames(datExpr))
    modTOM <- modTOM[probes, probes]
    attribute <- data.frame(
        symbol = symbols,
        color = moduleColors[probes],
        geneModuleMembership = abs(geneModuleMembership[probes,grep(module,colnames(MMPvalue))]),
        glycoType = glyco$Class[match(probes, glyco$Ensembl)],
        logFC = DE_ad$logFC[match(probes, DE_ad$ensembl_gene_id)],
        padj = DE_ad$padj[match(probes, DE_ad$ensembl_gene_id)]
    )
    # Export the network into edge and node list files Cytoscape can read
    cyt <- exportNetworkToCytoscape(
        modTOM,
        edgeFile = paste("CytoscapeInput-edges-", paste(module, collapse="-"), ".txt", sep=""),
        nodeFile = paste("CytoscapeInput-nodes-", paste(module, collapse="-"), ".txt", sep=""),
        weighted = TRUE,
        threshold = 0.02,
        nodeNames = probes,
        altNodeNames = symbols,
        nodeAttr = attribute
    )
}
```

